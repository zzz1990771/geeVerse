---
title: "Simulation 1da: One Iteration unbalanced and Heteroskedasticity"
output:
  html_document:
    df_print: paged
---



```{r,warning=FALSE,message=FALSE}
if(!require(mvtnorm)){install.packages("mvtnorm");library(mvtnorm)}else{library(mvtnorm)}
if(!require(quantreg)){install.packages("quantreg");library(quantreg)}else{library(quantreg)}
if(!require(MASS)){install.packages("MASS");library(MASS)}else{library(MASS)}
if(!require(foreach)){install.packages("foreach");library(foreach)}else{library(foreach)}
if(!require(tidyverse)){install.packages("tidyverse");library(tidyverse)}else{library(tidyverse)}
#self-made functions
source("./functions/qsicm.R")
source("./functions/plrq.R")
source("./functions/utils.R")
```

# Set the Data

In this simulation, we have 400 participants with 200 variables where 5 are important variables.

```{r}
#settings
n=n_sub=400
p=200
beta0=rep(1,7)
p0=length(beta0)
beta = c(beta0,rep(0,p-p0))
n_obs<-c(rep(10,n_sub/2),rep(5,n_sub/2))

ka = 1
rho=0.8
type="cs"
dis="normal"
n_sim = 1
#Please note that n_sim=2 is just for quick demo


```

# Simulate one iteration of data for illustration

```{r}
    #generate errors for each subject
    e = NULL
    id<-NULL
    for (i in 1:n_sub){
      id<-c(id,rep(i,n_obs[i]))
      sigmai=Siga_cov(rho,type,n_obs[i])
      if (dis=="normal") ei=rmvnorm(1, mean=rep(0, n_obs[i]), sigma=sigmai)
      if (dis=="t") ei=rmvt(1, sigmai, df = 4, delta = rep(0, n_obs[i]))
      e=c(e,ei);
    }

    #generate y and X
    N=sum(n_obs)
    nk=n_obs
    cn = c(0, cumsum(n_obs))
    x=X=matrix(rnorm(N*p),N,p)
    y=X%*%beta+(1+ka*abs(X[,1]))*e
    sim_data<-data.frame(y,x)
    
#write.csv(sim_data,"sim_data.csv",row.names = F )

```


```{r}
y = sim_data$y
X = as.matrix(sim_data%>% select(-y))

tau_list <- c(0.1,0.5,0.9)
sim=1
PQGEE_results <- NULL
final_results <- matrix(NA,ncol=21,nrow=6)
for(tau in tau_list){#tau=0.1
  

    #non-longitudinal quantile regression as initial
    betaint=coefficients(rq(y~0+X,tau = tau))

    #Apply proposed method with hbic tuning
    for(structure in c("Ind","CS","AR")){
      PQGEE_results[[structure]][[sim]] <-  qlingee_scad_hbic(x,y,betaint,nk,structure,tau=tau, max_it=100)
    }


# compile results ------------------------------------
  final_results[c(2*which(tau==tau_list)-1,2*which(tau==tau_list)),] <- compile_result_one(PQGEE_results,cutoff = 0.1,beta,beta0, structures = c("Ind","CS","AR"))
 

 
 }

colnames(final_results)=c(c("F1 score","TP","FP","TN", "FN","MSE","MAD"),c("F1 score","TP","FP","TN", "FN","MSE","MAD"),c("F1 score","TP","FP","TN", "FN","MSE","MAD"))
final_results <- final_results[!rowSums(is.na(final_results)),]
row.names(final_results) <- tau_list
#only report F1 MSE and MAD
condensed<-final_results[,c(1,6,7,8,13,14,15,20,21)]

 xtable::xtable(condensed)
# xtable::xtable(final_results,
#                digits=c(1,rep(c(2,2,2,4,4),3)))

#knitr::kable(final_results)


```


# Print results
```{r}
knitr::kable(final_results)

```

